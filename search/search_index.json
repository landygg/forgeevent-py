{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"forgeevent","text":"<p><code>forgeevent</code> is a Python library for event management and dispatching, designed to be simple, flexible, and extensible.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Register synchronous and asynchronous handlers</li> <li>Support for typed events (dataclasses, enums)</li> <li>Simple API for local event dispatch</li> <li>Easy integration with existing systems</li> </ul>"},{"location":"#main-modules","title":"Main Modules","text":"<ul> <li><code>forgeevent.handlers.local</code>: Local event handler</li> <li><code>forgeevent.typing</code>: Event types and aliases</li> <li><code>forgeevent.handlers.base</code>: Base for custom handlers</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install forgeevent\n</code></pre>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from forgeevent.handlers.local import local_handler\nfrom dataclasses import dataclass\n\n@dataclass\nclass MyEvent:\n    order_id: str\n\n@local_handler.register(event_name=\"my_event\")\ndef handle_my_event(event):\n    event_name, payload = event\n    print(f\"Event received: {payload.order_id}\")\n\nimport asyncio\nasyncio.run(local_handler.handle((\"my_event\", MyEvent(order_id=\"123\"))))\n</code></pre> <p>See the Usage Guide and module reference for more details.</p>"},{"location":"fastapi_example/","title":"FastAPI Integration Example","text":"<p>This section demonstrates how to integrate <code>forgeevent</code> with a FastAPI-like application, showing how to register event listeners and dispatch events in an async context.</p>"},{"location":"fastapi_example/#event-and-listener-definitions","title":"Event and Listener Definitions","text":"<p>First, define your event dataclasses and event types:</p> <pre><code>from dataclasses import dataclass\nfrom enum import Enum\nfrom forgeevent.handlers.local import LocalHandler\nfrom forgeevent.typing import Event\n\n@dataclass\nclass AbsPaymentEvent:\n    order_id: str\n\n@dataclass\nclass PaymentSucceededEvent(AbsPaymentEvent):\n    pass\n\n@dataclass\nclass PaymentFailedEvent(AbsPaymentEvent):\n    error: str\n\nclass EventType(Enum):\n    PAYMENT_FAILED = \"PaymentFailedEvent\"\n    PAYMENT_SUCCEEDED = \"PaymentSucceededEvent\"\n\nasync def handle_payment_failed_model(event: Event[PaymentFailedEvent]) -&gt; None:\n    \"\"\"\n    Handle payment failed events.\n    \"\"\"\n    event_name, payload = event\n    print(\n        f\"Handling event {event_name} for order_id: {payload.order_id} with error: {payload.error}\"\n    )\n\ndef register_listeners(local_handler: LocalHandler) -&gt; None:\n    local_handler.register(\n        event_name=EventType.PAYMENT_FAILED, listener=handle_payment_failed_model\n    )\n</code></pre>"},{"location":"fastapi_example/#application-lifespan-and-event-dispatch","title":"Application Lifespan and Event Dispatch","text":"<p>You can use an async context manager to manage application startup and shutdown, similar to FastAPI's lifespan events:</p> <pre><code>from fastapi import FastAPI\nfrom contextlib import asynccontextmanager\nfrom forgeevent.handlers.local import local_handler\nfrom test_registry import EventType, register_listeners, PaymentFailedEvent\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    register_listeners(local_handler)\n    print(\"ProviderFactory and PaymentService initialized.\")\n    yield\n    print(\"Cleaning up resources...\")\n\napp = FastAPI(lifespan=lifespan)\n\n@app.post(\"/pay/fail\")\nasync def trigger_failed_payment(order_id: str, error: str):\n    \"\"\"\n    Endpoint to simulate a failed payment event and dispatch it through forgeevent.\n    \"\"\"\n    await local_handler.handle((\n        EventType.PAYMENT_FAILED,\n        PaymentFailedEvent(order_id=order_id, error=error),\n    ))\n    return {\"status\": \"event dispatched\"}\n\n# To run the FastAPI app:\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(\"test_fastapi:app\", host=\"127.0.0.1\", port=8000, reload=True)\n</code></pre>"},{"location":"fastapi_example/#how-it-works","title":"How it works","text":"<ul> <li>The <code>register_listeners</code> function registers your event handlers with the local handler.</li> <li>The <code>lifespan</code> context manager simulates FastAPI's startup/shutdown hooks.</li> <li>The <code>main</code> function dispatches a sample event, which will trigger the registered handler.</li> </ul> <p>This pattern can be adapted to real FastAPI applications using the <code>lifespan</code> event or dependency injection.</p> <p>For more advanced usage, see the Usage Guide and the API Reference.</p>"},{"location":"modules/","title":"API Reference","text":""},{"location":"modules/#forgeeventhandlersbase","title":"forgeevent.handlers.base","text":"<p>Base classes for event handlers in the forgeevent framework.</p> <p>This module provides the abstract base class <code>BaseEventHandler</code>, which defines the interface for handling events. Subclasses must implement the <code>handle</code> method to define how individual events are processed.</p>"},{"location":"modules/#forgeevent.handlers.base.BaseEventHandler","title":"<code>BaseEventHandler</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for event handlers.</p> <p>This class defines the interface for handling events. Subclasses must implement the <code>handle</code> method to define how individual events are processed.</p>"},{"location":"modules/#forgeevent.handlers.base.BaseEventHandler--methods","title":"Methods","text":"<p>dispatch(events: Iterable[Event]) -&gt; None     Asynchronously dispatches a collection of events by handling each event. handle(event: Event) -&gt; None     Abstract method to handle a single event. Must be implemented by subclasses.</p> Source code in <code>forgeevent/handlers/base.py</code> <pre><code>class BaseEventHandler(ABC):\n    \"\"\"\n    Abstract base class for event handlers.\n\n    This class defines the interface for handling events.\n    Subclasses must implement the `handle` method\n    to define how individual events are processed.\n\n    Methods\n    -------\n    dispatch(events: Iterable[Event]) -&gt; None\n        Asynchronously dispatches a collection of events by handling each event.\n    handle(event: Event) -&gt; None\n        Abstract method to handle a single event. Must be implemented by subclasses.\n    \"\"\"\n\n    async def dispatch(self, events: Iterable[Event[Any]]) -&gt; None:\n        \"\"\"\n        Dispatch a collection of events by asynchronously handling each event.\n\n        Parameters\n        ----------\n        events : Iterable[Event]\n            An iterable of Event objects to be handled.\n        \"\"\"\n        await asyncio.gather(*[self.handle(event) for event in events])\n\n    @abc.abstractmethod\n    async def handle(self, event: Event[Any]) -&gt; None:\n        \"\"\"\n        Handle a single event.\n\n        Parameters\n        ----------\n        event : Event\n            The event to handle.\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"modules/#forgeevent.handlers.base.BaseEventHandler.dispatch","title":"<code>dispatch(events)</code>  <code>async</code>","text":"<p>Dispatch a collection of events by asynchronously handling each event.</p>"},{"location":"modules/#forgeevent.handlers.base.BaseEventHandler.dispatch--parameters","title":"Parameters","text":"<p>events : Iterable[Event]     An iterable of Event objects to be handled.</p> Source code in <code>forgeevent/handlers/base.py</code> <pre><code>async def dispatch(self, events: Iterable[Event[Any]]) -&gt; None:\n    \"\"\"\n    Dispatch a collection of events by asynchronously handling each event.\n\n    Parameters\n    ----------\n    events : Iterable[Event]\n        An iterable of Event objects to be handled.\n    \"\"\"\n    await asyncio.gather(*[self.handle(event) for event in events])\n</code></pre>"},{"location":"modules/#forgeevent.handlers.base.BaseEventHandler.handle","title":"<code>handle(event)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Handle a single event.</p>"},{"location":"modules/#forgeevent.handlers.base.BaseEventHandler.handle--parameters","title":"Parameters","text":"<p>event : Event     The event to handle.</p> Source code in <code>forgeevent/handlers/base.py</code> <pre><code>@abc.abstractmethod\nasync def handle(self, event: Event[Any]) -&gt; None:\n    \"\"\"\n    Handle a single event.\n\n    Parameters\n    ----------\n    event : Event\n        The event to handle.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"modules/#forgeeventhandlerslocal","title":"forgeevent.handlers.local","text":"<p>Local event handler for managing and dispatching events within the application.</p> <p>This module provides the <code>LocalHandler</code> class, which allows registering event listeners, retrieving registered listeners, and handling events asynchronously or synchronously.</p>"},{"location":"modules/#forgeevent.handlers.local.LocalHandler","title":"<code>LocalHandler</code>","text":"<p>               Bases: <code>BaseEventHandler</code></p> <p>Event handler that manages event listeners and dispatches events locally.</p> <p>This class allows registering listeners for specific event names and handles the execution of those listeners when an event is triggered. It supports both synchronous and asynchronous listeners.</p>"},{"location":"modules/#forgeevent.handlers.local.LocalHandler--attributes","title":"Attributes","text":"<p>_listeners : ClassVar[dict[EventName, list[Callable[..., Any]]]]     Dictionary mapping event names to lists of listener functions.</p> Source code in <code>forgeevent/handlers/local.py</code> <pre><code>class LocalHandler(BaseEventHandler):\n    \"\"\"\n    Event handler that manages event listeners and dispatches events locally.\n\n    This class allows registering listeners for specific event names and handles the execution\n    of those listeners when an event is triggered. It supports both synchronous and asynchronous\n    listeners.\n\n    Attributes\n    ----------\n    _listeners : ClassVar[dict[EventName, list[Callable[..., Any]]]]\n        Dictionary mapping event names to lists of listener functions.\n    \"\"\"\n\n    _listeners: ClassVar[dict[EventName, list[Callable[..., Any]]]] = {}\n\n    def _get_listeners(self, event_name: EventName) -&gt; list[Callable[..., Any]]:\n        \"\"\"\n        Retrieve the list of listeners for a specific event name.\n\n        Parameters\n        ----------\n        event_name : EventName\n            The name of the event to get listeners for.\n\n        Returns\n        -------\n        list[Callable[..., Any]]\n            The list of registered listeners for the event name.\n        \"\"\"\n        return self._listeners.get(event_name, [])\n\n    def _register_handler(self, event_name: EventName, listener: Callable[..., Any]) -&gt; None:\n        \"\"\"\n        Register a listener for a specific event name.\n\n        Parameters\n        ----------\n        event_name : EventName\n            The name of the event to register the listener for.\n        listener : Callable[..., Any]\n            The function to call when the event is triggered.\n        \"\"\"\n\n        logger.debug(\n            'Registering handler for event name: %s with listener: %s', event_name, listener\n        )\n\n        logger.debug('Current listeners for %s: %s', event_name, self._listeners)\n\n        self._listeners.setdefault(event_name, []).append(listener)\n\n        logger.debug('Updated listeners for %s: %s', event_name, self._listeners)\n\n    def register(\n        self, event_name: EventName, listener: Callable[..., Any] | None = None\n    ) -&gt; Callable[..., Any]:\n        \"\"\"\n        Register a listener for a specific event name, optionally as a decorator.\n\n        Parameters\n        ----------\n        event_name : EventName\n            The name of the event to listen for.\n        listener : Callable[..., Any] | None\n            The function to register, or None if used as a decorator.\n\n        Returns\n        -------\n        Callable[..., Any]\n            The registered listener or a decorator.\n\n        Examples\n        --------\n        As a decorator:\n            @handler.register(event_name=MyEvent)\n            def on_my_event(event):\n                ...\n\n        As a direct call:\n            def on_my_event(event):\n                ...\n            handler.register(event_name=MyEvent, listener=on_my_event)\n        \"\"\"\n\n        def wrapper(_listener: Callable[..., Any]) -&gt; Callable[..., Any]:\n            \"\"\"\n            Decorator to register a listener for an event name.\n            Args:\n                listener (Callable[..., Any]): The function to register as a listener.\n            Returns:\n                Callable[..., Any]: The wrapped listener function.\n            \"\"\"\n\n            logger.debug('Wrapping listener for event name: %s', event_name)\n            self._register_handler(event_name, _listener)\n            return _listener\n\n        if listener is None:\n            logger.debug('Registering as a decorator when no listener is provided.')\n            return wrapper\n\n        logger.debug('Registering listener directly for event name: %s', event_name)\n        return wrapper(_listener=listener)\n\n    async def handle(self, event: Event[Any]) -&gt; None:\n        \"\"\"\n        Handle a single event.\n\n        Parameters\n        ----------\n        event : Event\n            The event to handle.\n        \"\"\"\n\n        event_name, payload = event\n        logger.debug('Handling event: %s with payload: %s', event_name, payload)\n\n        listeners = self._get_listeners(event_name)\n\n        for listener in listeners:\n            if asyncio.iscoroutinefunction(listener):\n                logger.debug(\n                    'Calling async listener: %s for event: %s', listener.__name__, event_name\n                )\n                await listener(event)\n            else:\n                logger.debug('Calling sync listener: %s for event: %s', listener, event_name)\n                # Run the synchronous listener in a separate thread to avoid blocking the event loop\n                loop = asyncio.get_event_loop()\n                await loop.run_in_executor(None, listener, event)\n</code></pre>"},{"location":"modules/#forgeevent.handlers.local.LocalHandler.handle","title":"<code>handle(event)</code>  <code>async</code>","text":"<p>Handle a single event.</p>"},{"location":"modules/#forgeevent.handlers.local.LocalHandler.handle--parameters","title":"Parameters","text":"<p>event : Event     The event to handle.</p> Source code in <code>forgeevent/handlers/local.py</code> <pre><code>async def handle(self, event: Event[Any]) -&gt; None:\n    \"\"\"\n    Handle a single event.\n\n    Parameters\n    ----------\n    event : Event\n        The event to handle.\n    \"\"\"\n\n    event_name, payload = event\n    logger.debug('Handling event: %s with payload: %s', event_name, payload)\n\n    listeners = self._get_listeners(event_name)\n\n    for listener in listeners:\n        if asyncio.iscoroutinefunction(listener):\n            logger.debug(\n                'Calling async listener: %s for event: %s', listener.__name__, event_name\n            )\n            await listener(event)\n        else:\n            logger.debug('Calling sync listener: %s for event: %s', listener, event_name)\n            # Run the synchronous listener in a separate thread to avoid blocking the event loop\n            loop = asyncio.get_event_loop()\n            await loop.run_in_executor(None, listener, event)\n</code></pre>"},{"location":"modules/#forgeevent.handlers.local.LocalHandler.register","title":"<code>register(event_name, listener=None)</code>","text":"<p>Register a listener for a specific event name, optionally as a decorator.</p>"},{"location":"modules/#forgeevent.handlers.local.LocalHandler.register--parameters","title":"Parameters","text":"<p>event_name : EventName     The name of the event to listen for. listener : Callable[..., Any] | None     The function to register, or None if used as a decorator.</p>"},{"location":"modules/#forgeevent.handlers.local.LocalHandler.register--returns","title":"Returns","text":"<p>Callable[..., Any]     The registered listener or a decorator.</p>"},{"location":"modules/#forgeevent.handlers.local.LocalHandler.register--examples","title":"Examples","text":"<p>As a decorator:     @handler.register(event_name=MyEvent)     def on_my_event(event):         ...</p> As a direct call <p>def on_my_event(event):     ... handler.register(event_name=MyEvent, listener=on_my_event)</p> Source code in <code>forgeevent/handlers/local.py</code> <pre><code>def register(\n    self, event_name: EventName, listener: Callable[..., Any] | None = None\n) -&gt; Callable[..., Any]:\n    \"\"\"\n    Register a listener for a specific event name, optionally as a decorator.\n\n    Parameters\n    ----------\n    event_name : EventName\n        The name of the event to listen for.\n    listener : Callable[..., Any] | None\n        The function to register, or None if used as a decorator.\n\n    Returns\n    -------\n    Callable[..., Any]\n        The registered listener or a decorator.\n\n    Examples\n    --------\n    As a decorator:\n        @handler.register(event_name=MyEvent)\n        def on_my_event(event):\n            ...\n\n    As a direct call:\n        def on_my_event(event):\n            ...\n        handler.register(event_name=MyEvent, listener=on_my_event)\n    \"\"\"\n\n    def wrapper(_listener: Callable[..., Any]) -&gt; Callable[..., Any]:\n        \"\"\"\n        Decorator to register a listener for an event name.\n        Args:\n            listener (Callable[..., Any]): The function to register as a listener.\n        Returns:\n            Callable[..., Any]: The wrapped listener function.\n        \"\"\"\n\n        logger.debug('Wrapping listener for event name: %s', event_name)\n        self._register_handler(event_name, _listener)\n        return _listener\n\n    if listener is None:\n        logger.debug('Registering as a decorator when no listener is provided.')\n        return wrapper\n\n    logger.debug('Registering listener directly for event name: %s', event_name)\n    return wrapper(_listener=listener)\n</code></pre>"},{"location":"modules/#forgeeventtyping","title":"forgeevent.typing","text":"<p>Type definitions and aliases for ForgeEvent.</p> <p>This module provides type hints and utility types for event handling, payloads, and ASGI application interfaces, leveraging Pydantic models and standard Python typing constructs.</p>"},{"location":"usage/","title":"Usage Guide","text":"<p>This guide explains how to use the <code>forgeevent</code> library to manage and dispatch events in your Python applications.</p>"},{"location":"usage/#installation","title":"Installation","text":"<p>Install the library and its dependencies (requires Python 3.9+):</p> <pre><code>pip install forgeevent\n</code></pre> <p>Or, if you are developing locally:</p> <pre><code>make install\n</code></pre>"},{"location":"usage/#basic-concepts","title":"Basic Concepts","text":"<ul> <li>Event: A tuple of (event_name, payload), where <code>event_name</code> is a string or Enum, and <code>payload</code> is any object (often a dataclass).</li> <li>Handler: A function (sync or async) registered to respond to a specific event type.</li> <li>LocalHandler: The main class for registering and dispatching events locally.</li> </ul>"},{"location":"usage/#defining-events","title":"Defining Events","text":"<p>You can define your event payloads using dataclasses:</p> <pre><code>from dataclasses import dataclass\n\n@dataclass\nclass PaymentSucceededEvent:\n    order_id: str\n    amount: float\n    currency: str = \"USD\"\n</code></pre>"},{"location":"usage/#registering-handlers","title":"Registering Handlers","text":"<p>You can register handlers using the <code>@local_handler.register</code> decorator:</p> <pre><code>from forgeevent.handlers.local import local_handler\n\n@local_handler.register(event_name=\"payment_successful\")\ndef handle_payment(event):\n    event_name, payload = event\n    print(f\"Payment succeeded: {payload}\")\n</code></pre> <p>You can also register async handlers:</p> <pre><code>@local_handler.register(event_name=\"payment_successful\")\nasync def notify_payment(event):\n    event_name, payload = event\n    # send notification\n</code></pre>"},{"location":"usage/#dispatching-events","title":"Dispatching Events","text":"<p>To dispatch (trigger) an event:</p> <pre><code>import asyncio\n\nasync def main():\n    await local_handler.handle((\"payment_successful\", PaymentSucceededEvent(order_id=\"123\", amount=100.0)))\n\nasyncio.run(main())\n</code></pre>"},{"location":"usage/#advanced-using-enums-for-event-names","title":"Advanced: Using Enums for Event Names","text":"<pre><code>from enum import Enum\n\nclass EventType(Enum):\n    PAYMENT_SUCCESSFUL = \"payment_successful\"\n\n@local_handler.register(event_name=EventType.PAYMENT_SUCCESSFUL)\ndef handle_payment(event):\n    ...\n</code></pre>"},{"location":"usage/#testing-handlers","title":"Testing Handlers","text":"<p>You can test your handlers using pytest and pytest-asyncio. See the <code>tests/</code> folder for examples.</p> <p>For more details, see the API Reference and the source code.</p>"},{"location":"es/","title":"forgeevent","text":"<p>Nota: Esta documentaci\u00f3n est\u00e1 disponible en ingl\u00e9s por defecto. Puedes cambiar a espa\u00f1ol usando el selector de idioma.</p> <p><code>forgeevent</code> es una librer\u00eda Python para la gesti\u00f3n y dispatch de eventos, dise\u00f1ada para ser simple, flexible y extensible.</p>"},{"location":"es/#caracteristicas-principales","title":"Caracter\u00edsticas principales","text":"<ul> <li>Registro de handlers s\u00edncronos y as\u00edncronos</li> <li>Soporte para eventos tipados (dataclasses, enums)</li> <li>API simple para dispatch local de eventos</li> <li>Integraci\u00f3n f\u00e1cil con sistemas existentes</li> </ul>"},{"location":"es/#modulos-principales","title":"M\u00f3dulos principales","text":"<ul> <li><code>forgeevent.handlers.local</code>: Handler local para eventos</li> <li><code>forgeevent.typing</code>: Tipos y alias para eventos</li> <li><code>forgeevent.handlers.base</code>: Base para crear nuevos handlers</li> </ul>"},{"location":"es/#instalacion","title":"Instalaci\u00f3n","text":"<pre><code>pip install forgeevent\n</code></pre>"},{"location":"es/#ejemplo-rapido","title":"Ejemplo r\u00e1pido","text":"<pre><code>from forgeevent.handlers.local import local_handler\nfrom dataclasses import dataclass\n\n@dataclass\nclass MyEvent:\n    order_id: str\n\n@local_handler.register(event_name=\"my_event\")\ndef handle_my_event(event):\n    event_name, payload = event\n    print(f\"Evento recibido: {payload.order_id}\")\n\nimport asyncio\nasyncio.run(local_handler.handle((\"my_event\", MyEvent(order_id=\"123\"))))\n</code></pre> <p>Consulta la Gu\u00eda de Uso y la referencia de m\u00f3dulos para m\u00e1s detalles.</p>"},{"location":"es/usage/","title":"Gu\u00eda de Uso","text":"<p>Esta gu\u00eda explica c\u00f3mo usar la librer\u00eda <code>forgeevent</code> para gestionar y despachar eventos en tus aplicaciones Python.</p>"},{"location":"es/usage/#instalacion","title":"Instalaci\u00f3n","text":"<p>Instala la librer\u00eda y sus dependencias (requiere Python 3.9+):</p> <pre><code>pip install forgeevent\n</code></pre> <p>O, si desarrollas localmente:</p> <pre><code>make install\n</code></pre>"},{"location":"es/usage/#conceptos-basicos","title":"Conceptos B\u00e1sicos","text":"<ul> <li>Evento: Una tupla de (event_name, payload), donde <code>event_name</code> es un string o Enum, y <code>payload</code> es cualquier objeto (usualmente un dataclass).</li> <li>Handler: Una funci\u00f3n (sync o async) registrada para responder a un tipo de evento espec\u00edfico.</li> <li>LocalHandler: La clase principal para registrar y despachar eventos localmente.</li> </ul>"},{"location":"es/usage/#definiendo-eventos","title":"Definiendo Eventos","text":"<p>Puedes definir tus payloads de evento usando dataclasses:</p> <pre><code>from dataclasses import dataclass\n\n@dataclass\nclass PaymentSucceededEvent:\n    order_id: str\n    amount: float\n    currency: str = \"USD\"\n</code></pre>"},{"location":"es/usage/#registrando-handlers","title":"Registrando Handlers","text":"<p>Puedes registrar handlers usando el decorador <code>@local_handler.register</code>:</p> <pre><code>from forgeevent.handlers.local import local_handler\n\n@local_handler.register(event_name=\"payment_successful\")\ndef handle_payment(event):\n    event_name, payload = event\n    print(f\"Pago exitoso: {payload}\")\n</code></pre> <p>Tambi\u00e9n puedes registrar handlers as\u00edncronos:</p> <pre><code>@local_handler.register(event_name=\"payment_successful\")\nasync def notify_payment(event):\n    event_name, payload = event\n    # enviar notificaci\u00f3n\n</code></pre>"},{"location":"es/usage/#despachando-eventos","title":"Despachando Eventos","text":"<p>Para despachar (lanzar) un evento:</p> <pre><code>import asyncio\n\nasync def main():\n    await local_handler.handle((\"payment_successful\", PaymentSucceededEvent(order_id=\"123\", amount=100.0)))\n\nasyncio.run(main())\n</code></pre>"},{"location":"es/usage/#avanzado-usando-enums-para-nombres-de-evento","title":"Avanzado: Usando Enums para Nombres de Evento","text":"<pre><code>from enum import Enum\n\nclass EventType(Enum):\n    PAYMENT_SUCCESSFUL = \"payment_successful\"\n\n@local_handler.register(event_name=EventType.PAYMENT_SUCCESSFUL)\ndef handle_payment(event):\n    ...\n</code></pre>"},{"location":"es/usage/#testeo-de-handlers","title":"Testeo de Handlers","text":"<p>Puedes testear tus handlers usando pytest y pytest-asyncio. Consulta la carpeta <code>tests/</code> para ejemplos.</p> <p>Para m\u00e1s detalles, revisa la Referencia de la API y el c\u00f3digo fuente.</p>"}]}